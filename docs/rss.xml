<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>OmnisyR's Blog</title><link>https://OmnisyR.github.io</link><description>;;;eRecording the bits and pieces of scientific research, development, and life.;;;e;;;c记录科研、开发以及生活的点点滴滴;;;c</description><copyright>OmnisyR's Blog</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/68898477?s=400&amp;u=262ae3b76f651c62a82042317aaae313706c859c&amp;v=4</url><title>avatar</title><link>https://OmnisyR.github.io</link></image><lastBuildDate>Wed, 24 Sep 2025 03:12:02 +0000</lastBuildDate><managingEditor>OmnisyR's Blog</managingEditor><ttl>60</ttl><webMaster>OmnisyR's Blog</webMaster><item><title>;;;eNon-Solid Curves with Arrows in Matplotlib;;;e;;;cMatplotlib中带箭头的非实曲线;;;c</title><link>https://OmnisyR.github.io/post/%3B%3B%3BeNon-Solid%20Curves%20with%20Arrows%20in%20Matplotlib%3B%3B%3Be%3B%3B%3BcMatplotlib-zhong-dai-jian-tou-de-fei-shi-qu-xian-%3B%3B%3Bc.html</link><description>&lt;!-- ##{'script':'&lt;script src='https://OmnisyR.github.io/assets/HyperTOC.js'&gt;&lt;/script&gt;'}## --&gt;
;;;a
;;;;;;;eNote::note;;;e;;;c注释::注释;;;c;;;;
;;;a;;;e
## Introduction
This article will explain how to use Matplotlib to plot non-solid curves with arrows, as shown in the figure below:

`Gmeek-html&lt;p align='center'&gt;&lt;img srcset='https://OmnisyR.github.io/figs/arrow_example.png' width='400' height='400'/&gt;&lt;/p&gt;`

Matplotlib offers a rich set of built-in methods, yet it lacks a built-in function for drawing non-solid curves with arrows. While some online discussions exist on this topic, they haven't provided satisfactory solutions. Therefore, I conducted my own investigation into plotting such curves, aiming to create flawless, perfect non-solid curves with arrows.

## Methods Provided by Matplotlib and Related Issues
In Matplotlib, you can use FancyArrowPatch to create a curve with an arrowhead:
```python
import matplotlib.patches as patches
import matplotlib.pyplot as plt

fig, ax = plt.subplots(1, 1, figsize=(4, 4))
ax.set_xlim(0, 2)
ax.set_ylim(0, 2)
ax.add_patch(patches.FancyArrowPatch(
    posA=(0.1, 0.1), posB=(1.8, 1.8), arrowstyle='-|&gt;, head_width=4, head_length=8',
    connectionstyle='arc3,rad=0.3', color='#515151', shrinkA=0, shrinkB=0
))
plt.savefig('arrow_common.png', dpi=600)
```
`Gmeek-html&lt;p align='center'&gt;&lt;img srcset='https://OmnisyR.github.io/figs/arrow_common.png' width='400' height='400'/&gt;&lt;/p&gt;`

However, if you want to render this curve as a non-solid line by simply changing its style, problems will arise:
```python
# ...
ax.add_patch(patches.FancyArrowPatch(
  # ...
  linestyle='--'
)
# ...
```
`Gmeek-html&lt;p align='center'&gt;&lt;img srcset='https://OmnisyR.github.io/figs/arrow_error.png' width='400' height='400'/&gt;&lt;/p&gt;`

As can be seen, the arrow points are also drawn using dashed lines. Moreover, when using this method for plotting, the curvature of the curve is interface-dependent rather than coordinate-dependent. This means that when altering the x-axis or y-axis range of the chart, the curvature of the curve will still maintain visual consistency. In certain situations, this cannot be considered a rigorous plotting method.

## Method
By emulating the drawing method for non-solid lines with arrows, it can be treated as two components: the non-solid curve and the solid arrowhead.

### Non-Solid Curve
Matplotlib implements curve drawing using quadratic Bézier curves. Examining the source code reveals that given points A and B, and an angle rad in radians, the coordinates of control point C can be determined using the following formula:

$$
x_C = \frac{x_A + x_B}{2} + rad · (y_B - y_A)
$$
$$
y_C = \frac{y_A + y_B}{2} - rad · (x_B - x_A)
$$

`Gmeek-html&lt;p align='center'&gt;&lt;img srcset='https://OmnisyR.github.io/figs/arrow_arc3.png' width='400' height='400'/&gt;&lt;/p&gt;`

CA is tangent to the curve at point A, and CB is tangent to the curve at point B. This allows the non-solid curve to be drawn using the code below:
```python
import matplotlib.patches as patches
import matplotlib.pyplot as plt
import numpy as np

def draw_arc3(from_, to_, rad, detail=False, color='#515151'):
    x1, y1 = np.array(from_)
    x2, y2 = np.array(to_)
    dx, dy = x2 - x1, y2 - y1
    x12, y12 = (x1 + x2) / 2., (y1 + y2) / 2.
    cx, cy = x12 + rad * dy, y12 - rad * dx
    control_ = (cx, cy)
    vertices = [from_, control_, to_]
    codes = [patches.Path.MOVETO, patches.Path.CURVE3, patches.Path.CURVE3]
    path = patches.Path(vertices, codes)
    patch = patches.PathPatch(path, facecolor='none', edgecolor=color, linestyle='--', linewidth=1)
    ax.add_patch(patch)
    if not detail:
        return
    ax.scatter(control_[0], control_[1], c=color, marker='x', s=12, linewidths=0.8)
    ax.scatter(from_[0], from_[1], c=color, marker='x', s=12, linewidths=0.8)
    ax.scatter(to_[0], to_[1], c=color, marker='x', s=12, linewidths=0.8)
    ax.plot((control_[0], from_[0]), (control_[1], from_[1]), color=color, linewidth=.5, linestyle=':')
    ax.plot((control_[0], to_[0]), (control_[1], to_[1]), color=color, linewidth=.5, linestyle=':')
    ax.annotate(r'$A$', from_, ha='center', va='bottom')
    ax.annotate(r'$B$', to_, ha='center', va='bottom')
    ax.annotate(r'$C$', control_, ha='right', va='bottom')

fig, ax = plt.subplots(1, 1, figsize=(4, 4))
ax.set_xlim(0, 2)
ax.set_ylim(0, 2)
draw_arc3((0.1, 0.1), (1.8, 1.8), 0.3)
plt.savefig('arrow_arc3_dot.png', dpi=600)
```
`Gmeek-html&lt;p align='center'&gt;&lt;img srcset='https://OmnisyR.github.io/figs/arrow_arc3_dot.png' width='400' height='400'/&gt;&lt;/p&gt;`

### Solid Line Arrow
With control point C and target endpoint B already defined, drawing a solid line arrow is straightforward. The following code easily creates an arrow that meets the requirements:
```python
# ...
ax.annotate('', to_, xytext=control_, arrowprops=dict(
    linewidth=0, arrowstyle='-|&gt;, head_width=0.3, head_length=0.6',
    shrinkA=0, shrinkB=0, facecolor=color, linestyle='solid', mutation_scale=10
))
# ...
```

However, upon closer inspection, issues remain apparent: as shown in the figure below, the width at the very tip of the arrow is narrower than the curve's width, resulting in an aesthetically displeasing visual effect.
`Gmeek-html&lt;p align='center'&gt;&lt;img srcset='https://OmnisyR.github.io/figs/arrow_arc3_arrow_error.png' width='400' height='400'/&gt;&lt;/p&gt;`

To address this, consider placing a mask between the curve and the arrow to conceal the excess curve portion:
`Gmeek-html&lt;p align='center'&gt;&lt;img srcset='https://OmnisyR.github.io/figs/arrow_arc3_arrow_mask.png' width='400' height='400'/&gt;&lt;/p&gt;`

The placement of masks can be achieved through a simple algorithm:
```python
# ...
# Place the non-solid curve on layer -2
patch = patches.PathPatch(# ...
      zorder=-2)
# ...
size = 0.08
direction = -1 if control_[0] &lt; to_[0] else 1
mask = patches.FancyBboxPatch(
     (to_[0], to_[1] - size / 2), direction * size, size, boxstyle='square, pad=0',
     ec='red', fc='red', linewidth=1, zorder=-1
)
de = math.degrees(math.atan((control_[1] - to_[1]) / (control_[0] - to_[0])))
tf = transforms.Affine2D().rotate_deg_around(to_[0], to_[1], de) + ax.transData
cut.set_transform(tf)
ax.add_patch(cut)
# ...
```

`Gmeek-html&lt;p align='center'&gt;&lt;img srcset='https://OmnisyR.github.io/figs/arrow_direction.png' width='400' height='400'/&gt;&lt;/p&gt;`
This allows for precise placement of the mask. The center point in the image is point B, the target endpoint, with surrounding areas indicating the directions of potential control points.

### Non-Solid Curves with Arrows
Finally, by integrating these two components and specifying certain parameters for control, one can complete the drawing of non-solid curves with arrows.
```python
import math

import matplotlib.patches as patches
import matplotlib.pyplot as plt
import matplotlib.transforms as transforms
import numpy as np

def add_arrow(from_, to_, rad=0.3, control_=None, color='#515151',
              line='--', head_length=0.6, size=0.04, detail=False):
    '''
    :param from_:Starting point
    :param to_:Target endpoint
    :param rad:Curve radius
    :param control_:Control points;
                    if None, calculated based on the curvature of the curve.
    :param color:Drawing colors
    :param line:Curve Style
    :param head_length:Arrow size
    :param size:Mask Size
    :param detail:Select whether to draw details,
                  and manually adjust the mask size by drawing details.
    '''
    if control_ is None:
        x1, y1 = np.array(from_)
        x2, y2 = np.array(to_)
        dx, dy = x2 - x1, y2 - y1
        x12, y12 = (x1 + x2) / 2., (y1 + y2) / 2.
        cx, cy = x12 + rad * dy, y12 - rad * dx
        control_ = (cx, cy)
    vertices = [from_, control_, to_]
    codes = [patches.Path.MOVETO, patches.Path.CURVE3, patches.Path.CURVE3]
    path = patches.Path(vertices, codes)
    patch = patches.PathPatch(path, facecolor='none', edgecolor=color,
                              linestyle=line, linewidth=1, zorder=-2)
    ax.add_patch(patch)
    direction = -1 if control_[0] &lt; to_[0] else 1
    mask_c = 'red' if detail else 'white'
    mask = patches.FancyBboxPatch(
        (to_[0], to_[1] - size / 2), direction * size, size, boxstyle='square, pad=0',
        ec=mask_c, fc=mask_c, zorder=-1, linewidth=1)
    de = math.degrees(math.atan((control_[1] - to_[1]) / (control_[0] - to_[0])))
    tf = transforms.Affine2D().rotate_deg_around(to_[0], to_[1], de) + ax.transData
    mask.set_transform(tf)
    ax.add_patch(mask)
    ax.annotate('', to_, xytext=control_, arrowprops=dict(
        linewidth=0,
        arrowstyle='-|&gt;, head_width=%f, head_length=%f' % (head_length / 2, head_length),
        shrinkA=0, shrinkB=0, facecolor=color, linestyle='solid', mutation_scale=10
    ))
    if not detail:
        return
    ax.scatter(control_[0], control_[1], c=color, marker='x', s=12, linewidths=0.8)
    ax.scatter(from_[0], from_[1], c=color, marker='x', s=12, linewidths=0.8)
    ax.scatter(to_[0], to_[1], c=color, marker='x', s=12, linewidths=0.8)
    ax.plot((control_[0], from_[0]), (control_[1], from_[1]), color=color, linewidth=.5, linestyle=':')
    ax.plot((control_[0], to_[0]), (control_[1], to_[1]), color=color, linewidth=.5, linestyle=':')

def draw_eg():
    debug = False
    add_arrow((0.1, 0.1), (1.5, 1.6), rad=0.1, color=colors[1], detail=debug)
    add_arrow((0.4, 1.7), (1.4, 0.7), rad=0.8, color=colors[2], detail=debug)
    add_arrow((1.9, 1.9), (1.2, 0.1), rad=-0.2, color=colors[3], detail=debug)
    add_arrow((1.7, 0.7), (0.3, 1.8), rad=0.5, color=colors[4], detail=debug)
    plt.savefig('arrow_example%s.png' % ('_detail' if debug else ''), dpi=600)

fig, ax = plt.subplots(1, 1, figsize=(4, 4))
ax.set_xlim(0, 2)
ax.set_ylim(0, 2)
colors = ['#515151', '#CC9900', '#B177DE', '#37AD6B', '#1A6FDF']
draw_eg()
```
`Gmeek-html&lt;p align='center'&gt;&lt;img srcset='https://OmnisyR.github.io/figs/arrow_example_cat.png' width='800' height='400'/&gt;&lt;/p&gt;`
;;;e;;;c
## 介绍
本文将介绍如何使用Matplotlib来绘制带箭头的非实曲线，就像下图一样：

`Gmeek-html&lt;p align='center'&gt;&lt;img srcset='https://OmnisyR.github.io/figs/arrow_example.png' width='400' height='400'/&gt;&lt;/p&gt;`

Matplotlib内置的方法很丰富，但它却并未内置带箭头的非实曲线的方法，网络上也有一些相关讨论，但并未给出很好的解答。</description><guid isPermaLink="true">https://OmnisyR.github.io/post/%3B%3B%3BeNon-Solid%20Curves%20with%20Arrows%20in%20Matplotlib%3B%3B%3Be%3B%3B%3BcMatplotlib-zhong-dai-jian-tou-de-fei-shi-qu-xian-%3B%3B%3Bc.html</guid><pubDate>Wed, 24 Sep 2025 03:06:27 +0000</pubDate></item><item><title>;;;eModeling and Production of AC/43 in Guilty Gear;;;e;;;c罪恶装备中AC/43的建模与制作;;;c</title><link>https://OmnisyR.github.io/post/%3B%3B%3BeModeling%20and%20Production%20of%20AC-43%20in%20Guilty%20Gear%3B%3B%3Be%3B%3B%3Bc-zui-e-zhuang-bei-zhong-AC-43-de-jian-mo-yu-zhi-zuo-%3B%3B%3Bc.html</link><description>&gt; [!NOTE]
&gt; This article currently only supports Chinese.

&gt; [!CAUTION]
&gt; 施工中！

&lt;!-- ##{'script':'&lt;script src='https://OmnisyR.github.io/assets/HyperTOC.js'&gt;&lt;/script&gt;'}## --&gt;

;;;a
;;;;UE Viewer::[下载界面](https://www.gildor.org/en/projects/umodel#files);;;;
;;;a
## 写在前面
GGST中最吸引我的武器莫过于Unika的AC/43了。</description><guid isPermaLink="true">https://OmnisyR.github.io/post/%3B%3B%3BeModeling%20and%20Production%20of%20AC-43%20in%20Guilty%20Gear%3B%3B%3Be%3B%3B%3Bc-zui-e-zhuang-bei-zhong-AC-43-de-jian-mo-yu-zhi-zuo-%3B%3B%3Bc.html</guid><pubDate>Fri, 15 Aug 2025 08:07:17 +0000</pubDate></item><item><title>;;;eThe Foundation of Diffusion Models:;;;e;;;c扩散模型的基石：;;;cDDPM</title><link>https://OmnisyR.github.io/post/%3B%3B%3BeThe%20Foundation%20of%20Diffusion%20Models-%3B%3B%3Be%3B%3B%3Bc-kuo-san-mo-xing-de-ji-shi-%EF%BC%9A%3B%3B%3BcDDPM.html</link><description>&lt;!-- ##{'script':'&lt;script src='https://OmnisyR.github.io/assets/HyperTOC.js'&gt;&lt;/script&gt;'}## --&gt;
;;;a
;;;;;;;eCopy and paste the code directly::Or just click [me](https://github.com/OmnisyR/diffusion_demo/tree/main/ddpm/en) to go to the full version.;;;e;;;c直接复制粘贴::或是点[我](https://github.com/OmnisyR/diffusion_demo/tree/main/ddpm/cn)转到完全版。</description><guid isPermaLink="true">https://OmnisyR.github.io/post/%3B%3B%3BeThe%20Foundation%20of%20Diffusion%20Models-%3B%3B%3Be%3B%3B%3Bc-kuo-san-mo-xing-de-ji-shi-%EF%BC%9A%3B%3B%3BcDDPM.html</guid><pubDate>Fri, 25 Jul 2025 07:02:25 +0000</pubDate></item><item><title>;;;eAn Overview of Diffusion Models;;;e;;;c扩散模型概述;;;c</title><link>https://OmnisyR.github.io/post/%3B%3B%3BeAn%20Overview%20of%20Diffusion%20Models%3B%3B%3Be%3B%3B%3Bc-kuo-san-mo-xing-gai-shu-%3B%3B%3Bc.html</link><description>&gt; [!NOTE]
&gt; This article currently only supports Chinese.

&gt; [!CAUTION]
&gt; 施工中！

&lt;!-- ##{'script':'&lt;script src='https://OmnisyR.github.io/assets/HyperTOC.js'&gt;&lt;/script&gt;'}## --&gt;

;;;a
;;;;生成式模型::在实际运用中，依据用户的引导性输入或是不依靠输入，就可以生成出一系列数据的模型（这些数据往往在现实中不存在）;;;;
;;;;变分自编码器::简称VAE;;;;
;;;;生成式对抗模型::GANs;;;;
;;;;泛性::不拘泥于数据集，能够;;;;
;;;;质量::看起来和真的一样;;;;
;;;;Deep Unsupervised Learning using Nonequilibrium Thermodynamics::文章地址：https://arxiv.org/abs/1503.03585;;;;
;;;;Denoising Diffusion Probabilistic Models(DDPM)::文章地址：https://arxiv.org/abs/2006.11239;;;;
;;;;一定比例::又称噪声时间表。</description><guid isPermaLink="true">https://OmnisyR.github.io/post/%3B%3B%3BeAn%20Overview%20of%20Diffusion%20Models%3B%3B%3Be%3B%3B%3Bc-kuo-san-mo-xing-gai-shu-%3B%3B%3Bc.html</guid><pubDate>Thu, 24 Jul 2025 03:02:32 +0000</pubDate></item><item><title>;;;eNavi;;;e;;;c导航;;;c</title><link>https://OmnisyR.github.io/post/%3B%3B%3BeNavi%3B%3B%3Be%3B%3B%3Bc-dao-hang-%3B%3B%3Bc.html</link><description>&lt;!-- ##{'script':'&lt;script src='https://OmnisyR.github.io/assets/GmeekTOC.js'&gt;&lt;/script&gt;'}## --&gt;

## ;;;eDiffusion Models;;;e;;;c扩散模型;;;c
[;;;eAn overview of Diffusion Models;;;e;;;c扩散模型概述;;;c](https://omnisyr.github.io/post/%3B%3B%3BeAn%20Overview%20of%20Diffusion%20Models%3B%3B%3Be%3B%3B%3Bc-kuo-san-mo-xing-gai-shu-%3B%3B%3Bc.html)

### 离散型扩散模型
[;;;eThe Foundation of Diffusion Models:;;;e;;;c扩散模型的基石：;;;cDDPM](https://omnisyr.github.io/post/%3B%3B%3BeThe%20Foundation%20of%20Diffusion%20Models-%3B%3B%3Be%3B%3B%3Bc-kuo-san-mo-xing-de-ji-shi-%EF%BC%9A%3B%3B%3BcDDPM.html)

### 连续型扩散模型

## MCMod开发

## 串口屏开发

## 碎碎念
。</description><guid isPermaLink="true">https://OmnisyR.github.io/post/%3B%3B%3BeNavi%3B%3B%3Be%3B%3B%3Bc-dao-hang-%3B%3B%3Bc.html</guid><pubDate>Thu, 24 Jul 2025 03:01:23 +0000</pubDate></item><item><title>链接库</title><link>https://OmnisyR.github.io/link.html</link><description>## 记录一些常用的小工具
[文件结构树生成器](https://tree.nathanfriend.com/)
。</description><guid isPermaLink="true">https://OmnisyR.github.io/link.html</guid><pubDate>Fri, 15 Aug 2025 07:25:31 +0000</pubDate></item></channel></rss>